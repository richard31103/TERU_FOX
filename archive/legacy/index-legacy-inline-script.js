// ???? Audio Engine ???????????????????????????????????????????????????????????????????????????????????????????????????? const audioCtx = new (window.AudioContext || window.webkitAudioContext)(); let audioMuted = false;   function toggleAudioGlobal() {     audioMuted = !audioMuted;     const btn = document.getElementById('audio-toggle-btn');       if (audioMuted) {         document.getElementById('bgm').pause();         btn.innerHTML = `<svg class="qa-svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18V5l12-2v13"/><circle cx="6" cy="18" r="3"/><circle cx="18" cy="16" r="3"/><line x1="2" y1="2" x2="22" y2="22"/></svg><span class="tooltip" id="lang-ui-audio">${l10n[currentLang].ui.audioOff}</span>`;     } else {         ensureAudio();         document.getElementById('bgm').play().catch(() => { });         btn.innerHTML = `<svg class="qa-svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18V5l12-2v13"/><circle cx="6" cy="18" r="3"/><circle cx="18" cy="16" r="3"/></svg><span class="tooltip" id="lang-ui-audio">${l10n[currentLang].ui.audioOn}</span>`;     } }   // Tiny synth tap: short band-pass burst ??typewriter feel function playTap() {     if (audioMuted) return;     const vol = parseFloat(document.getElementById('sfx-vol').value) / 100;     if (vol === 0) return;     const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.04, audioCtx.sampleRate);     const data = buf.getChannelData(0);     for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (data.length * 0.18));     const src = audioCtx.createBufferSource();     src.buffer = buf;     const filter = audioCtx.createBiquadFilter();     filter.type = 'bandpass';     filter.frequency.value = 3200;     filter.Q.value = 1.2;     const gain = audioCtx.createGain();     gain.gain.value = vol * 0.13;     src.connect(filter);     filter.connect(gain);     gain.connect(audioCtx.destination);     src.start(); }   // Soft hover blip: short sine fade function playHover() {     if (audioMuted) return;     const vol = parseFloat(document.getElementById('sfx-vol').value) / 100;     if (vol === 0) return;     const osc = audioCtx.createOscillator();     osc.type = 'sine';     osc.frequency.setValueAtTime(900, audioCtx.currentTime);     osc.frequency.exponentialRampToValueAtTime(700, audioCtx.currentTime + 0.06);     const gain = audioCtx.createGain();     gain.gain.setValueAtTime(vol * 0.06, audioCtx.currentTime);     gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.08);     osc.connect(gain);     gain.connect(audioCtx.destination);     osc.start();     osc.stop(audioCtx.currentTime + 0.09); }   // Click confirm tone: two-tone short blip function playClick() {     if (audioMuted) return;     const vol = parseFloat(document.getElementById('sfx-vol').value) / 100;     if (vol === 0) return;     [520, 760].forEach((freq, i) => {         const osc = audioCtx.createOscillator();         osc.type = 'sine';         osc.frequency.value = freq;         const gain = audioCtx.createGain();         const t = audioCtx.currentTime + i * 0.05;         gain.gain.setValueAtTime(vol * 0.08, t);         gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.09);         osc.connect(gain);         gain.connect(audioCtx.destination);         osc.start(t);         osc.stop(t + 0.1);     }); }   // Resume AudioContext on first interaction (browser policy) function ensureAudio() {     if (audioCtx.state === 'suspended') audioCtx.resume(); }   // BGM const bgmEl = document.getElementById('bgm'); function startBGM() {     if (audioMuted) return;     ensureAudio();     const vol = parseFloat(document.getElementById('bgm-vol').value) / 100;     bgmEl.volume = vol;     bgmEl.play().catch(() => { }); }   // Wire hover/click SFX to all buttons and qa-btns after DOM ready function wireSfx() {     document.querySelectorAll('button, .qa-btn, .choice-btn').forEach(el => {         el.addEventListener('mouseenter', () => { ensureAudio(); playHover(); });         el.addEventListener('click', () => { ensureAudio(); playClick(); });     }); }   // ???? Particles Generation ???????????????????????????????????????????????????????????????????????????????????? function createParticles() {     const container = document.getElementById('particles-container');     const particleCount = 45; // Amount of floating particles       for (let i = 0; i < particleCount; i++) {         const p = document.createElement('div');         p.className = 'particle';           // Random size between 2px and 4px         const size = Math.random() * 2 + 2;         p.style.width = `${size}px`;         p.style.height = `${size}px`;           // Random position         p.style.left = `${Math.random() * 100}%`;         p.style.top = `${Math.random() * 100}%`;           // Random animation delay and duration         const duration = Math.random() * 8 + 6; // 6s to 14s         const delay = Math.random() * 14;           p.style.animationDuration = `${duration}s`;         p.style.animationDelay = `-${delay}s`;           // Random horizontal drift         const xDrift = (Math.random() - 0.5) * 80;         p.style.setProperty('--x-drift', `${xDrift}px`);           container.appendChild(p);     } }   document.addEventListener('DOMContentLoaded', () => {     wireSfx();     createParticles();     startAssetLoader(); });   // Also start BGM on first click anywhere document.addEventListener('click', startBGM, { once: true });   // ???? Dialogue Script & L10n ???????????????????????????????????????????????????????????????????????? let currentLang = 'tw';   const l10n = {     tw: {         startBtn: '???',         deathText: '??????????????,         speaker: '??????,         lines: [             '???????????????????????????',             '?????????????????????????????????..',             '????????????????????????????????????!',             '???????...?????!',             '??..????????????????'         ],         choiceTitle: '?????????????????????????????,         choices: [             '??????????????????????UwU',             '????????,             '????????',             '???OOXX'         ],         responses: [             '????!!(??????',             '??????..??????????',             '????! ????!!!',             '???????????         ],         ui: {             docTitle: '????????????????????????????? - ?????, gameTitle: '????????????????????????????? ???????,             save: '?????????', load: '??????, autoBtn: '???', skip: '???????', gearBtn: '??????????????', chapTitle: '?????????????????????????,             cg: 'CG ??????????', audioOn: '??? (??', audioOff: '??? (??', history: '??????????, map: '???',             prev: '?? ???????????, histBtn: '?????????,             histTitle: '?? ??????????, closeHist: '???',             settingTitle: '??????????????????', textSpeed: '??????????, bgm: 'BGM ???', sfx: '??????', voice: '??????????',             fullScreen: '?????????????????, lang: '???????????', closeSet: '???????????????',             on: '???', off: '???', tw: '?????????????????, jp: '????????????????????, en: 'EN',             socialPrompt: '???????????????????? TERU FOX ???????????????', social: '?????????',             toastSave: '?? ???????, toastLoad: '?? ????????????...', toastSkip: '???????????, toastAutoOn: '????????? ON',             toastAutoOff: '????????? OFF', toastContinue: '???????????..', noHistory: '?????????????..',             ooxxTitle: 'OOXX ????', ooxxYourTurn: '??????? (O)', ooxxAiTurn: '????????...',             ooxxDraw: '???????', ooxxLose: '???????????, ooxxTapReturn: '????????????????????         }     },     en: {         startBtn: 'Start',         deathText: 'You were bitten to death',         speaker: '??????,         lines: [             'Are you seriously not some weird furry?',             'Who asks to go home with me right after meeting...',             'And absolutely NO touching my tail!',             'If you touch it, I will... bite you!!',             'W-What are you trying to do?'         ],         choiceTitle: '??Choose your action ??,         choices: [             'Pounce and touch the tail UwU',             'Hug and rub the belly',             'Touch the OO',             'I want to OOXX with you'         ],         responses: [             'No!! (bite bite bite)',             'W..What?',             'No! Pervert!!!',             'Help meee'         ],         ui: {             docTitle: "Da'an Forest Park - Meadow", gameTitle: "Da'an Forest Park ??Meadow",             save: 'Save', load: 'Load', skip: 'Skip', gearBtn: '??Settings', chapTitle: 'First Encounter',             audioOn: 'Music (On)', audioOff: 'Music (Off)', history: 'Log', map: 'Map',             prev: '?? Prev', histBtn: 'Log',             histTitle: '?? Dialogue Log', closeHist: 'Close',             settingTitle: '??Settings', textSpeed: 'Text Speed', bgm: 'BGM Vol', sfx: 'SFX Vol', voice: 'Voice Vol',             fullScreen: 'Fullscreen', lang: 'Language', closeSet: 'Close Settings',             on: 'On', off: 'Off', tw: 'TW', jp: 'JP', en: 'EN',             socialPrompt: "Would you like to visit TERU FOX's social media page?", social: 'Social',             toastSave: '?? Saved', toastLoad: '?? Loading...', toastSkip: '??Skipping', toastAutoOn: '??Auto Play ON',             toastAutoOff: '??Auto Play OFF', toastContinue: '??Story continues...', noHistory: 'No history...',             ooxxTitle: 'OOXX Game', ooxxYourTurn: 'Your turn (O)', ooxxAiTurn: '??????is thinking...',             ooxxDraw: 'Draw', ooxxLose: 'You Lost', ooxxTapReturn: 'Tap anywhere to return'         }     },     jp: {         startBtn: '?????????',         deathText: '??????????????????????????',         speaker: '??????,         lines: [             '????????????????????????????????????????????????????????????????????????????????????????????????????????,             '??????????????????????????????????????????????????????????????????????????????????????????',             '??????????????????????????????????????????????????????????????????????????????????????',             '?????????????????????????????????????????????????????????????????????????????????????,             '?????????????????????????????????????????????????????????????????????????'         ],         choiceTitle: '????????????,         choices: [             '?????????????????????????? UwU',             '?????????????????????,             'OO???????,             '???????????????????????????????????????         ],         responses: [             '????! (????????',             '?????..?????',             '??????????!!!',             '?????????'         ],         ui: {             docTitle: '????????????????????????????? - ???', gameTitle: '????????????????????????????? ?????',             save: '???????, load: '??????, skip: '?????????', gearBtn: '??????????????', chapTitle: '????????????,             audioOn: '????????(????)', audioOff: '????????(???)', history: '?????????, map: '?????,             prev: '?? ???', histBtn: '?????????,             histTitle: '?? ???????????????????, closeHist: '?????,             settingTitle: '??????????????', textSpeed: '??????????????, bgm: 'BGM???', sfx: 'SE???', voice: '??????????????????????,             fullScreen: '???????????????, lang: '????????????, closeSet: '??????????????????',             on: '????', off: '???', tw: 'TW', jp: 'JP', en: 'EN',             socialPrompt: 'TERU FOX??????????????????????????????????', social: '????????????????Ⅹ????????????????,             toastSave: '?? ??????????, toastLoad: '?? ????????...', toastSkip: '??????????????????, toastAutoOn: '??????????,             toastAutoOff: '???????????, toastContinue: '??????????..', noHistory: '???????????????????...',             ooxxTitle: 'OOXX??????, ooxxYourTurn: '???????????????????????????????(O)', ooxxAiTurn: '??????????????????????????????...',             ooxxDraw: '???????', ooxxLose: '????????????????????????????', ooxxTapReturn: '?????????????         }     } };   const script = [     { type: 'line' },     { type: 'line' },     { type: 'line' },     { type: 'line' },     { type: 'line' },     { type: 'choice' }, ];   let lineIndex = 0; let charIndex = 0; let typeTimer = null; let isTyping = false; let autoPlay = false; let textSpeedMs = 45; let inChoiceMode = false;   // Character Animation State let isSpeaking = false; let isAngry = false; let blinkTimeout = null; let speakInterval = null;   const charIdle = document.getElementById('char-idle'); const charBlink = document.getElementById('char-blink'); const charSpeak = document.getElementById('char-speak'); const charAngry = document.getElementById('char-angry');   const dialogueText = document.getElementById('dialogue-text'); const speakerPlate = document.getElementById('speaker-plate'); const dialogueArea = document.getElementById('dialogue-area'); const choicePanel = document.getElementById('choice-panel'); // const totalDots = script.length; (Removed)   function setCharState(state) {     charIdle.classList.remove('active');     charBlink.classList.remove('active');     charSpeak.classList.remove('active');     if (charAngry) charAngry.classList.remove('active');       if (isAngry) {         if (charAngry) charAngry.classList.add('active');         return;     }       if (state === 'idle') charIdle.classList.add('active');     else if (state === 'blink') charBlink.classList.add('active');     else if (state === 'speak') charSpeak.classList.add('active');     else if (state === 'angry') { if (charAngry) charAngry.classList.add('active'); } }   function scheduleNextBlink() {     if (isSpeaking) return;     // Human-like blink interval: 2s to 6s     const nextBlinkTime = 2000 + Math.random() * 4000;     blinkTimeout = setTimeout(() => {         if (isSpeaking) return;         setCharState('blink');         setTimeout(() => {             if (isSpeaking) return;             setCharState('idle');             // 20% chance for a quick double blink             if (Math.random() < 0.2) {                 setTimeout(() => {                     if (isSpeaking) return;                     setCharState('blink');                     setTimeout(() => {                         if (isSpeaking) return;                         setCharState('idle');                         scheduleNextBlink();                     }, 100);                 }, 100);             } else {                 scheduleNextBlink();             }         }, 100); // 100ms blink duration     }, nextBlinkTime); }   function startSpeakingAnimation() {     if (speakInterval) clearInterval(speakInterval);     let mouthOpen = true;     setCharState('speak'); // start with mouth open     speakInterval = setInterval(() => {         mouthOpen = !mouthOpen;         setCharState(mouthOpen ? 'speak' : 'idle');     }, 120); // Fast toggle every 120ms }   function stopSpeakingAnimation() {     if (speakInterval) {         clearInterval(speakInterval);         speakInterval = null;     } }   function setTyping(flag) {     isTyping = flag;     dialogueText.classList.toggle('typing', flag);       isSpeaking = flag;       if (isAngry) {         stopSpeakingAnimation();         clearTimeout(blinkTimeout);         setCharState('angry');         return;     }       if (isSpeaking) {         clearTimeout(blinkTimeout); // Stop blinking when starting to type         startSpeakingAnimation();     } else {         stopSpeakingAnimation();         setCharState('idle');         scheduleNextBlink(); // Resume blinking when done typing     } }   function renderLine(idx) {     const entry = script[idx];     const t = l10n[currentLang];       if (entry.type === 'choice') {         inChoiceMode = true;         dialogueArea.classList.add('choices-mode');         choicePanel.classList.add('visible');         document.getElementById('chapter-badge').style.opacity = '0';         document.getElementById('chapter-badge').style.pointerEvents = 'none';           // Update choice labels         document.querySelector('.choice-label').textContent = t.choiceTitle;         const choiceBtns = document.querySelectorAll('.choice-btn .choice-text');         t.choices.forEach((text, i) => choiceBtns[i].textContent = text);           return;     }       inChoiceMode = false;     dialogueArea.classList.remove('choices-mode');     choicePanel.classList.remove('visible');     document.getElementById('chapter-badge').style.opacity = '1';     document.getElementById('chapter-badge').style.pointerEvents = 'auto';     speakerPlate.textContent = t.speaker;     dialogueText.textContent = '';     charIndex = 0;     setTyping(true);     clearInterval(typeTimer);       const lineText = t.lines[idx];       typeTimer = setInterval(() => {         if (charIndex < lineText.length) {             dialogueText.textContent += lineText[charIndex++];             playTap();         } else {             clearInterval(typeTimer);             setTyping(false);             // Add to history once complete typing             if (!dialogueHistory.some(r => r.text === lineText && (!r.isChoice))) {                 dialogueHistory.push({ speaker: t.speaker, text: lineText, isChoice: false });             }             if (autoPlay && idx < script.length - 1) setTimeout(nextLine, 1800);         }     }, textSpeedMs); }   // function updateDots(idx) { ... } (Removed)   function nextLine() {     if (inChoiceMode) return;     if (isTyping) {         clearInterval(typeTimer);         setTyping(false);         // Use localized text, not the undefined script[].text         const lineText = l10n[currentLang].lines[lineIndex];         if (lineText) dialogueText.textContent = lineText;         return;     }     if (lineIndex < script.length - 1) {         lineIndex++;         renderLine(lineIndex);     } else {         showToast(l10n[currentLang].ui.toastContinue);     } }   function prevLine() {     if (lineIndex > 0) {         lineIndex--;         renderLine(lineIndex);     } }   let isDeathSequence = false;   function pickChoice(idx) {     inChoiceMode = false;     dialogueArea.classList.remove('choices-mode');     choicePanel.classList.remove('visible');     document.getElementById('chapter-badge').style.opacity = '1';     document.getElementById('chapter-badge').style.pointerEvents = 'auto';       // Choice 3 ??launch OOXX minigame instead of normal response     if (idx === 3) {         startOOXX();         return;     }       isAngry = true;     setCharState('angry');       const t = l10n[currentLang];     const responseText = t.responses[idx];       // Add user choice to history     dialogueHistory.push({ speaker: '', text: t.choices[idx], isChoice: true });       speakerPlate.textContent = t.speaker;     dialogueText.textContent = '';     charIndex = 0;     setTyping(true);     clearInterval(typeTimer);       typeTimer = setInterval(() => {         if (charIndex < responseText.length) {             dialogueText.textContent += responseText[charIndex++];             playTap();         } else {             clearInterval(typeTimer);             setTyping(false);             dialogueHistory.push({ speaker: t.speaker, text: responseText, isChoice: false });             isDeathSequence = true;             setTimeout(triggerDeath, 1000); // 1s pause after text before death screen         }     }, textSpeedMs); }   // ???? OOXX MINI-GAME ???????????????????????????????????????????????????????????????????????????????????????????? const OOXX_AI = 'X', OOXX_HU = 'O'; let ooxxBoard = [], ooxxLocked = false;   function checkOOXX(b) {     const lines = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]];     for (const ln of lines) {         const [a, c, d] = ln;         if (b[a] && b[a] === b[c] && b[a] === b[d]) return { winner: b[a], line: ln };     }     return null; }   function minimax(b, isMax) {     const r = checkOOXX(b);     if (r) return r.winner === OOXX_AI ? 10 : -10;     if (b.every(c => c)) return 0;     let best = isMax ? -Infinity : Infinity;     for (let i = 0; i < 9; i++) {         if (!b[i]) {             b[i] = isMax ? OOXX_AI : OOXX_HU;             const val = minimax(b, !isMax);             b[i] = '';             best = isMax ? Math.max(best, val) : Math.min(best, val);         }     }     return best; }   function getBestOOXX(b) {     let bestVal = -Infinity, bestMove = -1;     for (let i = 0; i < 9; i++) {         if (!b[i]) {             b[i] = OOXX_AI;             const val = minimax(b, false);             b[i] = '';             if (val > bestVal) { bestVal = val; bestMove = i; }         }     }     return bestMove; }   const OOXX_SVG = {     X: `<svg viewBox="0 0 40 40"><line x1="10" y1="10" x2="30" y2="30"/><line x1="30" y1="10" x2="10" y2="30"/></svg>`,     O: `<svg viewBox="0 0 40 40"><circle cx="20" cy="20" r="12"/></svg>` };   function renderOOXX(highlightLine) {     document.querySelectorAll('.ooxx-cell').forEach((cell, i) => {         cell.className = 'ooxx-cell';         cell.innerHTML = ooxxBoard[i] ? OOXX_SVG[ooxxBoard[i]] : '';         if (ooxxBoard[i]) cell.classList.add('taken', ooxxBoard[i]);         if (highlightLine && highlightLine.includes(i)) cell.classList.add('win-line');     }); }   function ooxxSetStatus(key) {     const el = document.getElementById('ooxx-status');     if (el) el.textContent = l10n[currentLang].ui[key] || key; }   const OVERLAY_FADE_MS = 1000; const OOXX_ENTRY_TRANSITION = { fadeInMs: 1200, holdMs: 1800, fadeOutMs: 1200 }; const OOXX_RESULT_TRANSITION = { fadeInMs: 900, holdMs: 700, fadeOutMs: 900 }; const OOXX_TRANSITION_CANCELLED = 'OOXX_TRANSITION_CANCELLED'; let ooxxTransitionLock = false; let ooxxTransitionToken = 0;   function waitMs(ms) {     return new Promise(resolve => setTimeout(resolve, ms)); }   function logOOXXTransition(token, phase, detail) {     const ts = new Date().toISOString();     const msg = detail ? `${phase} | ${detail}` : phase;     console.log(`[OOXX][${ts}][token:${token}] ${msg}`); }   function beginOOXXTransition(label) {     ooxxTransitionLock = true;     ooxxTransitionToken += 1;     const token = ooxxTransitionToken;     logOOXXTransition(token, `${label} begin`);     return token; }   function endOOXXTransition(token, label) {     if (token !== ooxxTransitionToken) return;     ooxxTransitionLock = false;     logOOXXTransition(token, `${label} end`); }   function cancelOOXXTransitions(reason) {     ooxxTransitionToken += 1;     ooxxTransitionLock = false;     setOOXXCurtainInstant(false);     logOOXXTransition(ooxxTransitionToken, 'cancel', reason || 'manual reset'); }   function ensureOOXXToken(token) {     if (token !== ooxxTransitionToken) {         throw new Error(OOXX_TRANSITION_CANCELLED);     } }   function setOOXXCurtainInstant(visible) {     const curtain = document.getElementById('ooxx-curtain');     curtain.classList.remove('dark');     curtain.style.transition = 'none';     curtain.style.opacity = visible ? '1' : '0';     curtain.style.pointerEvents = visible ? 'all' : 'none';     void curtain.offsetWidth;     curtain.style.transition = ''; }   function animateOOXXCurtainTo({ token, visible, durationMs, phase }) {     const curtain = document.getElementById('ooxx-curtain');     const targetOpacity = visible ? '1' : '0';     const fromOpacity = visible ? '0' : '1';       return new Promise(resolve => {         let settled = false;         const settle = (reason) => {             if (settled) return;             settled = true;             curtain.removeEventListener('transitionend', onEnd);             curtain.style.pointerEvents = visible ? 'all' : 'none';             logOOXXTransition(token, `${phase} end`, `reason=${reason}`);             resolve();         };         const onEnd = (e) => {             if (e.target === curtain && e.propertyName === 'opacity') settle('transitionend');         };           logOOXXTransition(token, `${phase} start`, `duration=${durationMs}ms`);         curtain.style.pointerEvents = 'all';         curtain.classList.remove('dark');           const currentOpacity = parseFloat(getComputedStyle(curtain).opacity);         if (Number.isNaN(currentOpacity) || Math.abs(currentOpacity - parseFloat(targetOpacity)) < 0.01 || durationMs <= 0) {             curtain.style.transition = 'none';             curtain.style.opacity = targetOpacity;             curtain.style.pointerEvents = visible ? 'all' : 'none';             logOOXXTransition(token, `${phase} end`, 'reason=instant');             resolve();             return;         }           if (Math.abs(currentOpacity - parseFloat(fromOpacity)) > 0.01) {             curtain.style.transition = 'none';             curtain.style.opacity = fromOpacity;             void curtain.offsetWidth;         }           curtain.addEventListener('transitionend', onEnd);         curtain.style.transition = `opacity ${durationMs}ms ease`;         requestAnimationFrame(() => {             curtain.style.opacity = targetOpacity;         });           setTimeout(() => settle('timeout'), durationMs + 180);     }); }   async function runCurtainTransition({ fadeInMs, holdMs, fadeOutMs }, { token, label, onBlack } = {}) {     const activeToken = token || ooxxTransitionToken;     const tag = label || 'transition';       ensureOOXXToken(activeToken);     await animateOOXXCurtainTo({         token: activeToken,         visible: true,         durationMs: fadeInMs,         phase: `${tag}: fade-in`     });     ensureOOXXToken(activeToken);       if (typeof onBlack === 'function') {         logOOXXTransition(activeToken, `${tag}: on-black start`);         await onBlack();         logOOXXTransition(activeToken, `${tag}: on-black end`);         ensureOOXXToken(activeToken);     }       logOOXXTransition(activeToken, `${tag}: hold start`, `${holdMs}ms`);     await waitMs(holdMs);     ensureOOXXToken(activeToken);     logOOXXTransition(activeToken, `${tag}: hold end`);       await animateOOXXCurtainTo({         token: activeToken,         visible: false,         durationMs: fadeOutMs,         phase: `${tag}: fade-out`     });     ensureOOXXToken(activeToken); }   function endOOXX(winnerMark, line) {     ooxxLocked = true;     renderOOXX(line);     const ui = l10n[currentLang].ui;     const isDraw = !winnerMark;     const resultText = isDraw ? ui.ooxxDraw : ui.ooxxLose;     const cls = isDraw ? 'draw' : 'lose';     const subText = isDraw ? '' : (         currentLang === 'jp' ? '?????????????????????????????????' :             currentLang === 'en' ? 'Win and you\'d get a special CG...' :                 '?????????????     );       setTimeout(async () => {         if (ooxxTransitionLock) return;         const token = beginOOXXTransition('result');         try {             const screen = document.getElementById('ooxx-screen');             stopOOXXAmbience();               // Stop BGM             document.getElementById('bgm').pause();               // Play death sound effect on a loss (same as triggerDeath)             if (!isDraw && !audioMuted) {                 const deathSfx = document.getElementById('sfx-death');                 deathSfx.volume = parseFloat(document.getElementById('sfx-vol').value) / 100;                 deathSfx.currentTime = 0;                 deathSfx.play().catch(() => { });             }               const resultEl = document.getElementById('ooxx-result');             const textEl = document.getElementById('ooxx-result-text');             const subEl = document.getElementById('ooxx-result-sub');             textEl.textContent = resultText;             textEl.className = cls;             subEl.textContent = subText;               await runCurtainTransition(OOXX_RESULT_TRANSITION, {                 token,                 label: 'result',                 onBlack: async () => {                     screen.style.transition = 'none';                     screen.classList.add('hidden');                     void screen.offsetWidth;                     screen.style.transition = '';                       resultEl.style.transition = 'none';                     resultEl.classList.remove('hidden');                     resultEl.classList.remove('show-text');                     void resultEl.offsetWidth;                     resultEl.style.transition = '';                 }             });               setTimeout(() => {                 if (token !== ooxxTransitionToken) return;                 resultEl.classList.add('show-text');             }, 120);               resultEl.addEventListener('click', function once() {                 resultEl.removeEventListener('click', once);                 resultEl.classList.remove('show-text'); // reset for next time                 // Return to title and restart BGM                 returnToTitle(resultEl, () => {                     lineIndex = 0;                     document.getElementById('bgm').currentTime = 0;                     startBGM();                 });             });         } catch (err) {             if (!err || err.message !== OOXX_TRANSITION_CANCELLED) {                 console.error('OOXX result transition error:', err);             }         } finally {             endOOXXTransition(token, 'result');         }     }, 900); }   function aiOOXXMove() {     const move = getBestOOXX(ooxxBoard);     if (move === -1) return;     ooxxBoard[move] = OOXX_AI;     playOOXXPlace(true); // AI piece sound     const res = checkOOXX(ooxxBoard);     if (res || ooxxBoard.every(c => c)) {         endOOXX(res ? res.winner : null, res ? res.line : null);     } else {         renderOOXX();         ooxxLocked = false;         ooxxSetStatus('ooxxYourTurn');     } }   async function startOOXX() {     if (ooxxTransitionLock) return;     const token = beginOOXXTransition('entry');       try {         ooxxBoard = Array(9).fill('');         ooxxLocked = true;         const ui = l10n[currentLang].ui;         const screen = document.getElementById('ooxx-screen');         const resultEl = document.getElementById('ooxx-result');           await runCurtainTransition(OOXX_ENTRY_TRANSITION, {             token,             label: 'entry',             onBlack: async () => {                 // Build OOXX while fully black.                 screen.innerHTML = `             <div id="ooxx-title">${ui.ooxxTitle}</div>             <div id="ooxx-grid">${Array.from({ length: 9 }, (_, i) => `<div class="ooxx-cell" data-i="${i}"></div>`).join('')}</div>             <div id="ooxx-status">${ui.ooxxAiTurn}</div>`;                 screen.querySelectorAll('.ooxx-cell').forEach(cell => {                     cell.addEventListener('click', () => {                         const i = +cell.dataset.i;                         if (ooxxLocked || ooxxBoard[i]) return;                         ooxxLocked = true;                         ooxxBoard[i] = OOXX_HU;                         playOOXXPlace(false);                         const res = checkOOXX(ooxxBoard);                         if (res || ooxxBoard.every(c => c)) {                             endOOXX(res ? res.winner : null, res ? res.line : null);                             return;                         }                         renderOOXX();                         ooxxSetStatus('ooxxAiTurn');                         setTimeout(aiOOXXMove, 500);                     });                 });                   // Show OOXX instantly behind black curtain.                 screen.style.transition = 'none';                 screen.classList.remove('hidden');                 void screen.offsetWidth;                 screen.style.transition = '';                 resultEl.classList.add('hidden');                 resultEl.classList.remove('show-text');             }         });           setTimeout(() => {             if (token !== ooxxTransitionToken) return;             aiOOXXMove();         }, 90);     } catch (err) {         if (!err || err.message !== OOXX_TRANSITION_CANCELLED) {             console.error('OOXX entry transition error:', err);         }     } finally {         endOOXXTransition(token, 'entry');     } }   // ???? OOXX PIECE PLACEMENT SOUND ???????????????????????????????????????????????????????????? // Short crisp tone, similar in character to playTap() but deeper function playOOXXPlace(isAI) {     if (audioMuted) return;     try {         const vol = parseFloat(document.getElementById('sfx-vol').value) / 100;         if (vol === 0) return;         const freq = isAI ? 300 : 500; // AI(X) = lower thud, Player(O) = higher click         const osc = audioCtx.createOscillator();         osc.type = 'sine';         osc.frequency.setValueAtTime(freq, audioCtx.currentTime);         osc.frequency.exponentialRampToValueAtTime(freq * 0.80, audioCtx.currentTime + 0.07);         const gain = audioCtx.createGain();         gain.gain.setValueAtTime(vol * 0.14, audioCtx.currentTime);         gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.09);         osc.connect(gain);         gain.connect(audioCtx.destination);         osc.start();         osc.stop(audioCtx.currentTime + 0.10);     } catch (e) { } }   // Kept as no-ops so existing call sites don't break function startOOXXAmbience() { } function stopOOXXAmbience() { }   function triggerDeath() {     const deathScreen = document.getElementById('death-screen');     deathScreen.classList.remove('hidden');       // Stop BGM and play death sound     document.getElementById('bgm').pause();     if (!audioMuted) {         const deathSfx = document.getElementById('sfx-death');         deathSfx.volume = parseFloat(document.getElementById('sfx-vol').value) / 100;         deathSfx.currentTime = 0; // ensure it plays from beginning         deathSfx.play().catch(() => { });     }       // Show text after screen turns black     setTimeout(() => {         deathScreen.classList.add('show-text');           // Return to title after keeping death screen for a few seconds         setTimeout(() => {             deathScreen.classList.remove('show-text');             returnToTitle(deathScreen);         }, 4000);     }, 1000); }   // Click anywhere to advance document.getElementById('game-container').addEventListener('click', function (e) {     if (e.target.closest('button, .qa-btn, #settings-overlay, #top-bar, #choice-panel, #ooxx-result, #ooxx-screen')) return;     const r = document.createElement('div');     r.className = 'ripple';     const rect = this.getBoundingClientRect();     r.style.left = (e.clientX - rect.left - 25) + 'px';     r.style.top = (e.clientY - rect.top - 25) + 'px';     this.appendChild(r);     setTimeout(() => r.remove(), 560);       if (!isDeathSequence && !isTyping) {         nextLine();     } });   // Trigger death shortcut if clicking anywhere on the black death screen overlay (to force show text) document.getElementById('death-screen').addEventListener('click', function (e) {     // If we've started the sequence but the text hasn't shown up yet, fast-forward it     this.classList.add('show-text'); });   // ???? Settings ???????????????????????????????????????????????????????????????????????????????????????????????????????????? const overlay = document.getElementById('settings-overlay'); function openSettings() { overlay.style.display = 'flex'; setTimeout(() => overlay.classList.add('open'), 10); } function closeSettings() { overlay.classList.remove('open'); setTimeout(() => overlay.style.display = 'none', 300); } function handleSettingsClick(e) { if (e.target === overlay) closeSettings(); }   function setLanguage(lang) {     currentLang = lang;     ['tw', 'jp', 'en'].forEach(l => {         document.getElementById('tog-lang-' + l).classList.toggle('on', l === lang);         const titleBtn = document.getElementById('title-lang-' + l);         if (titleBtn) titleBtn.classList.toggle('on', l === lang);     });     updateUIText();       // Re-render current line immediately to reflect language change if not in transition     if (!isDeathSequence && !isTyping && !inChoiceMode && script[lineIndex]) {         const t = l10n[lang];         speakerPlate.textContent = t.speaker;         dialogueText.textContent = t.lines[lineIndex];     } else if (inChoiceMode) {         const t = l10n[lang];         document.querySelector('.choice-label').textContent = t.choiceTitle;         const choiceBtns = document.querySelectorAll('.choice-btn .choice-text');         t.choices.forEach((text, i) => choiceBtns[i].textContent = text);     } }   function updateUIText() {     const t = l10n[currentLang];     const ui = t.ui;       document.getElementById('lang-ui-docTitle').textContent = ui.docTitle;     document.querySelector('.lang-ui-gameTitle').textContent = ui.gameTitle;     document.getElementById('lang-btn-gear').textContent = ui.gearBtn;     document.getElementById('lang-ui-chapTitle').textContent = ui.chapTitle;       document.getElementById('start-btn').textContent = t.startBtn;     document.getElementById('death-text').textContent = t.deathText;       document.getElementById('lang-ui-social').textContent = ui.social;     document.getElementById('lang-ui-audio').textContent = audioMuted ? ui.audioOff : ui.audioOn;     <span class="tooltip" id="lang-ui-history">&#23565;&#35441;&#32000;&#37636;</span>     document.getElementById('lang-ui-map').textContent = ui.map;       document.getElementById('lang-btn-prev').textContent = ui.prev;     document.getElementById('lang-btn-hist').textContent = ui.histBtn;       document.getElementById('lang-ui-hist-title').textContent = ui.histTitle;     document.getElementById('close-history').textContent = ui.closeHist;       document.getElementById('lang-ui-settings-title').textContent = ui.settingTitle;     document.getElementById('lang-ui-text-speed').textContent = ui.textSpeed;     document.getElementById('lang-ui-bgm').textContent = ui.bgm;     document.getElementById('lang-ui-sfx').textContent = ui.sfx;     document.getElementById('lang-ui-voice').textContent = ui.voice;     <span class="setting-label" id="lang-ui-fullscreen">&#20840;&#34722;&#24149;&#39023;&#31034;</span>     const autoEl = document.getElementById('lang-ui-auto');     if (autoEl) autoEl.textContent = ui.autoPlay;     document.getElementById('lang-ui-lang').textContent = ui.lang;     document.getElementById('close-settings').textContent = ui.closeSet;       document.getElementById('tog-fs-off').textContent = ui.off;     document.getElementById('tog-fs-on').textContent = ui.on;     document.getElementById('tog-lang-tw').textContent = ui.tw;     document.getElementById('tog-lang-jp').textContent = ui.jp;     document.getElementById('tog-lang-en').textContent = ui.en; }   function setToggle(group, val) {     const map = {         fs: { ids: ['tog-fs-off', 'tog-fs-on'], vals: ['off', 'on'] },         auto: { ids: ['tog-auto-off', 'tog-auto-on'], vals: ['off', 'on'] }     };     if (map[group]) {         map[group].ids.forEach((id, i) =>             document.getElementById(id).classList.toggle('on', map[group].vals[i] === val)         );     }     if (group === 'auto') autoPlay = (val === 'on'); }   function updateSlider(el) {     const pct = ((el.value - el.min) / (el.max - el.min) * 100).toFixed(1) + '%';     el.style.setProperty('--val', pct);     if (el.id === 'text-speed') textSpeedMs = Math.round(90 - el.value * 8);     if (el.id === 'bgm-vol') bgmEl.volume = el.value / 100; }   function toggleAutoPlay(btn) {     autoPlay = !autoPlay;     btn.classList.toggle('active', autoPlay);     showToast(autoPlay ? l10n[currentLang].ui.toastAutoOn : l10n[currentLang].ui.toastAutoOff);     if (autoPlay && !isTyping && lineIndex < script.length - 1) setTimeout(nextLine, 1800); }   function toggleFullscreen() {     if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(() => { });     else document.exitFullscreen(); }   // ???? GYROSCOPE PARALLAX (mobile only) ???????????????????????????????????????????????????????????? // Uses object-position to shift the visible crop of character images ??safe, // no edge bleed, no transform override conflicts. (function () {     if (!window.DeviceOrientationEvent) return;     if (window.matchMedia('(hover: hover)').matches) return; // skip on desktop       const MAX_SHIFT = 5;   // px: how far image crops can shift     const SMOOTH = 0.07; // lerp speed (lower = smoother)       let baseGamma = null, baseBeta = null;     let targetX = 0, targetY = 0;     let smoothX = 0, smoothY = 0;       function lerp(a, b, t) { return a + (b - a) * t; }     function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }       function onOrientation(e) {         const gamma = e.gamma != null ? e.gamma : 0;         const beta = e.beta != null ? e.beta : 0;         if (baseGamma === null) { baseGamma = gamma; baseBeta = beta; return; }         const dg = clamp(gamma - baseGamma, -25, 25);         const db = clamp(beta - baseBeta, -20, 20);         targetX = (dg / 25) * MAX_SHIFT;         targetY = (db / 20) * MAX_SHIFT;     }       function tick() {         smoothX = lerp(smoothX, targetX, SMOOTH);         smoothY = lerp(smoothY, targetY, SMOOTH);           // Shift the visible crop of every char image via object-position.         // This never moves the element boundary, so no black edges appear.         const px = `calc(50% + ${smoothX.toFixed(2)}px)`;         const py = `calc(50% + ${smoothY.toFixed(2)}px)`;         document.querySelectorAll('.char-img').forEach(img => {             img.style.objectPosition = `${px} ${py}`;         });           requestAnimationFrame(tick);     }       function startGyro() {         if (typeof DeviceOrientationEvent.requestPermission === 'function') {             DeviceOrientationEvent.requestPermission()                 .then(state => {                     if (state === 'granted') {                         window.addEventListener('deviceorientation', onOrientation);                         requestAnimationFrame(tick);                     }                 }).catch(() => { });         } else {             window.addEventListener('deviceorientation', onOrientation);             requestAnimationFrame(tick);         }     }       // First tap satisfies iOS gesture requirement for permission dialog     document.addEventListener('click', startGyro, { once: true }); })();   // ???? ASSET PRELOADER FOR GITHUB PAGES ????????????????????????????????????????????????????????????   const assetsToLoad = [     'no speak.jpg',     'blank.jpg',     'speak.jpg',     'angry.jpg',     'BG.jpg',     'ad630f06-22cd-45a6-842b-1e8e78c36a61.jpg',     'fox-face_1f98a.png' ];   let loadedAssetsCount = 0;   function updateLoaderProgress() {     loadedAssetsCount++;     const pct = Math.floor((loadedAssetsCount / assetsToLoad.length) * 100);     document.getElementById('loading-bar-fill').style.width = pct + '%';     document.getElementById('loading-text').textContent = `Loading Assets... ${pct}%`;       if (loadedAssetsCount >= assetsToLoad.length) {         setTimeout(() => {             document.getElementById('loading-container').style.display = 'none';             document.getElementById('start-btn').style.display = 'block';         }, 400);     } }   function startAssetLoader() {     assetsToLoad.forEach(src => {         if (src.endsWith('.wav') || src.endsWith('.mp3')) {             const audio = new Audio();             audio.oncanplaythrough = updateLoaderProgress;             audio.onerror = updateLoaderProgress; // fallback to avoid hard lock             audio.src = src;         } else {             const img = new Image();             img.onload = updateLoaderProgress;             img.onerror = updateLoaderProgress;             img.src = src;         }     }); }   // ???? MAP AND HISTORY ????????????????????????????????????????????????????????????????????????????????????????????   function openSocial() {     if (confirm(l10n[currentLang].ui.socialPrompt)) {         window.open('https://www.facebook.com/teru.fox', '_blank');     } }   const mapOverlay = document.getElementById('map-overlay'); const histOverlay = document.getElementById('history-overlay');   function openMap() { mapOverlay.classList.remove('hidden'); } function closeMap(e) { if (e) e.stopPropagation(); mapOverlay.classList.add('hidden'); }   const dialogueHistory = []; // Stores {speaker, text, isChoice}   function openHistory() {     const list = document.getElementById('history-list');     list.innerHTML = '';       if (dialogueHistory.length === 0) {         list.innerHTML = `<div class="history-entry"><div class="history-text" style="text-align:center; opacity:0.5;">${l10n[currentLang].ui.noHistory}</div></div>`;     } else {         dialogueHistory.forEach(r => {             const div = document.createElement('div');             div.className = 'history-entry';             if (r.isChoice) {                 div.innerHTML = `<div class="history-text history-choice">??${r.text}</div>`;             } else {                 div.innerHTML = `                     <div class="history-speaker">${r.speaker}</div>                     <div class="history-text">${r.text}</div>                 `;             }             list.appendChild(div);         });     }     histOverlay.classList.remove('hidden');       // Scroll to bottom     setTimeout(() => { list.scrollTop = list.scrollHeight; }, 10); }   function closeHistory() { histOverlay.classList.add('hidden'); } function handleHistoryClick(e) { if (e.target === histOverlay) closeHistory(); }   // function showHistory() { showToast('?? ??????????????????); } (Replaced by real history panel)   // ???? Game Flow Control ???????????????????????????????????????????????????????????????????????????????????????? function startGame() {     ensureAudio();     startBGM();     document.getElementById('title-screen').classList.add('hidden');       // Thorough state reset to prevent stale state from previous session     clearInterval(typeTimer);     typeTimer = null;     lineIndex = 0;     charIndex = 0;     isTyping = false;     inChoiceMode = false;     isDeathSequence = false;     isAngry = false;     dialogueHistory.length = 0;       // Reset UI elements that may be dirty     dialogueArea.classList.remove('choices-mode');     choicePanel.classList.remove('visible');     dialogueText.textContent = '';     document.getElementById('chapter-badge').style.opacity = '1';     document.getElementById('chapter-badge').style.pointerEvents = 'auto';       // Clear any inline styles that could interfere with hiding/showing     document.getElementById('title-screen').style.opacity = '';     document.getElementById('title-screen').classList.add('hidden');     cancelOOXXTransitions('startGame reset');     document.getElementById('ooxx-screen').classList.add('hidden');     const ooxxResultEl = document.getElementById('ooxx-result');     ooxxResultEl.classList.add('hidden');     ooxxResultEl.classList.remove('show-text');       // Fade out BG.jpg splash as character fades in     const splash = document.getElementById('bg-splash');     if (splash) splash.classList.add('fade-out');       clearTimeout(blinkTimeout);     stopSpeakingAnimation();     setCharState('idle');     scheduleNextBlink();     // Wait for BG.jpg to finish fading (1.4s) before starting dialogue     setTimeout(() => renderLine(0), 1400); }   function transitionToTitleWithCover(sourceOverlayEl, cleanupFn) {     if (typeof cleanupFn === 'function') cleanupFn();     const title = document.getElementById('title-screen');     title.style.opacity = '';     title.classList.remove('hidden');     setTimeout(() => {         if (sourceOverlayEl) {             sourceOverlayEl.classList.add('hidden');             sourceOverlayEl.classList.remove('show-text');         }     }, OVERLAY_FADE_MS + 40); }   function returnToTitle(sourceOverlayEl, cleanupFn) {     // Stop logic / reset     clearInterval(typeTimer);     isDeathSequence = false;     isAngry = false;     setCharState('idle'); // revert character to idle     dialogueText.textContent = ''; // clear text     cancelOOXXTransitions('returnToTitle reset');     transitionToTitleWithCover(sourceOverlayEl, cleanupFn); }   // ???? Start ???????????????????????????????????????????????????????????????????????????????????????????????????????????????? scheduleNextBlink(); // Do not renderLine(0) immediately, wait for Start // renderLine(0);
